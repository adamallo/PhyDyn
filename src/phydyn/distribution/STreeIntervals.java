package phydyn.distribution;


import java.util.List;

import beast.core.CalculationNode;
import beast.core.Description;
import beast.core.Input;
import beast.core.Input.Validate;
import beast.evolution.tree.Node;
import beast.evolution.tree.Tree;
import beast.evolution.tree.coalescent.IntervalType;

/**
 * Extracts the intervals from a beast.tree.
 * @author Igor Siveroni 
 * Based on code from BEAST's TreeIntervals class by Andrew Rambaut and Alexei Drummond.
 * We have kept the node index representation used for sorting. We have modified (and made
 * a copy of) the heapsort methods so they use a new compare method.
 * 
 * Basic implementation of tree intervals. Intervals are generated by arrivals of sample and
 * coalescent events, defined by tree leaves (tips) and internal nodes, respectively.
 * Tree intervals are, essentially, a sorted list of nodes, starting with the node lowest in height, 
 * and ending with the the root. Equally high nodes are sorted based on child-parent
 * relationships such that a child node will never appear after its parent.
 * The first interval will have length zero.
 *
 */
@Description("Extracts the intervals from a tree. Points in the intervals " +
        "are defined by the nodes (and nodeheights) in the tree.")
public class STreeIntervals extends CalculationNode {
    final public Input<Tree> treeInput = new Input<>("tree", "tree for which to calculate the intervals", Validate.REQUIRED);
    
    /**
     * interval lengths
     */
    protected double[] intervals;
    protected double[] storedIntervals;
    
    protected Node[] events;  

    /** interval times **/
    protected double[] times;
    protected int[] indices;
    
    double[] storedTimes;
    int[] storedIndices;
   
    protected int intervalCount = 0;
    protected int storedIntervalCount = 0;

    /**
     * are the intervals known?
     */
    protected boolean intervalsKnown = false;
    
          
    public STreeIntervals() {
        super();
    }

    public STreeIntervals(Tree tree) {
        init(tree);
    }

    // @Override
    public void initAndValidate() {
        // this initialises data structures that store/restore might need
        calculateIntervals();
        intervalsKnown = false;
    }

    /**
     * CalculationNode methods *
     */
    // @Override
    protected boolean requiresRecalculation() {
        intervalsKnown = false;
        return true;
    }

    // @Override
    protected void restore() {
 
        //intervalsKnown = false;
        double[] tmp = storedIntervals;
        storedIntervals = intervals;
        intervals = tmp;
        
        int[] tmp1 = storedIndices;
        storedIndices = indices;
        indices = tmp1;
        
        double[] tmp2 = storedTimes;
        storedTimes = times;
        times = tmp2;

        int tmp3 = storedIntervalCount;
        storedIntervalCount = intervalCount;
        intervalCount = tmp3;
        
        events = new Node[intervalCount];
        Node[] nodes = treeInput.get().getNodesAsArray();
        for(int i=0; i < intervalCount; i++)
        	events[i] = nodes[indices[i]];
        
        super.restore();
   
        
    } 


    // @Override
    protected void store() {
    	System.arraycopy(intervals, 0, storedIntervals, 0, intervals.length);
        System.arraycopy(indices, 0, storedIndices, 0, intervals.length);
        System.arraycopy(times, 0, storedTimes, 0, intervals.length);
        storedIntervalCount = intervalCount;
        super.store();
    }

    /**
     * Specifies that the intervals are unknown (i.e., the beast.tree has changed).
     */
    public void setIntervalsUnknown() {
        intervalsKnown = false;
    }

//	public int getSampleCount() {
 //       return treeInput.get().getInternalNodeCount();
  //  }

    /**
     * get number of intervals
     */
	public int getIntervalCount() {
        if (!intervalsKnown) {
            calculateIntervals();
        }
        return intervalCount;
    }

    /**
     * Gets an interval.
     */
	public double getIntervalLength(int i) {
        if (!intervalsKnown) {
            calculateIntervals();
        }
        if (i < 0 || i >= intervalCount) throw new IllegalArgumentException();
        return intervals[i];
    }


    public Node getEvent(int i) {
    	if (!intervalsKnown) {
            calculateIntervals();
        }
        if (i >= intervalCount) throw new IllegalArgumentException();
        return events[i];
        // new - not working for flu example - need testing
        //Node[] nodes = treeInput.get().getNodesAsArray();
        //return nodes[indices[i]];
    }
    
    public double getHeight(int i) {
    	if (!intervalsKnown) {
            calculateIntervals();
        }
        if (i >= intervalCount) throw new IllegalArgumentException();       
        return times[indices[i]];
    }
    
    /**
     * Returns the type of interval observed.
     */
	public IntervalType getIntervalType(int i) {
        if (!intervalsKnown) {
            calculateIntervals();
        }
        if (i >= intervalCount) throw new IllegalArgumentException();
        
        // new - not working for flu example - need testing
        //Node[] nodes = treeInput.get().getNodesAsArray();
        //int numChildren = nodes[indices[i]].getChildCount();
        
        int numChildren = events[i].getChildCount();
        
        if (numChildren>0)
        	return IntervalType.COALESCENT;
        else
        	return IntervalType.SAMPLE;

    }


    /**
     * get the total height of the genealogy represented by these
     * intervals.
     */
    // Improve
	public double getTotalDuration() {

        if (!intervalsKnown) {
            calculateIntervals();
        }
        double height = 0.0;
        for (int j = 0; j < intervalCount; j++) {
            height += intervals[j];
        }
        
        return height;
    }


    /**
     * Recalculates all the intervals for the given beast.tree.
     */
    protected void calculateIntervals() {   	
        Tree tree = treeInput.get();
        final int nodeCount = tree.getNodeCount();
 
        if (intervals == null || intervals.length != nodeCount) {
            intervals = new double[nodeCount];
            times = new double[nodeCount];
            indices = new int[nodeCount];
            
            storedIntervals = new double[nodeCount];
            storedIndices = new int[nodeCount];
            storedTimes = new double[nodeCount];
        } 
       
        // node idx =node nr
        Node[] nodes = tree.getNodesAsArray();    
        for (int i = 0; i < nodes.length; i++) {
            Node node = nodes[i];
            times[i] = node.getHeight();
        }
        for (int i = 0; i < indices.length; i++) {
            indices[i] = i;
        }

        heapsort(times, indices);
        
        // debug: check order
        //if (!checkOrder()) {
        //   System.out.println("------------ wrong order!!! - trying other sort");
        //	heapsort2(times, indices);
        //	if (!checkOrder()) {
        //		System.out.println("Error with sort implementations");
        //	}
        //} 

       
        // start is the time of the first tip
        events = new Node[nodeCount];
        double start = times[indices[0]];
        int nodeNo = 0;
        intervalCount = 0;
        while (nodeNo < nodeCount) {
            double finish = times[indices[nodeNo]];
            nodeNo += 1;           
            intervals[intervalCount] = finish - start;
            events[intervalCount] = nodes[indices[intervalCount]];
            start = finish;
            intervalCount += 1;          
        }
        intervalsKnown = true;
        
        getTotalDuration();
        
    }    
    
    /**
     * Checks that sorted nodes (indices array) have the parent-child property.
     * This is a quick check: it doesn't keep track of active lineages nor requires other
     * structures, just the sorted array of nodes.
     *
     * @param indices an array of indices i.e. node nr's
     */
    protected boolean checkOrder() {
    	boolean[] visited = new boolean[indices.length];
    	Node[] nodes = treeInput.get().getNodesAsArray();
    
    	for(int i=0 ; i < indices.length; i++) {   		
    		Node node = nodes[indices[i]];
    		
    		List<Node> children = node.getChildren();
    		for(Node child: children) {
    			if (!visited[child.getNr()]) {
    				System.out.println("Child node: "+child.getNr()+" not visited");
    				return false;
    			}
    		}
    		visited[node.getNr()] = true;
    	}   
    	return true;
    }
    

    /**
     * Returns the time of the end of an interval
     *
     * @param i which interval
     * @return end time
     */
    public double getIntervalTime(int i) {
        if (!intervalsKnown) {
            calculateIntervals();
        }
        return times[indices[i]];
    }
 
    public void printIntervals() {
    	if (!intervalsKnown) {
            calculateIntervals();
        }   	
    	System.out.print("\nIntervals: "+this.getIntervalCount());
    	System.out.println(" -- duration: "+this.getTotalDuration());
    	for(int interval=0; interval < this.getIntervalCount(); interval++) {
			System.out.print(Math.round(this.getIntervalLength(interval)*100)/100.0+" ");
			System.out.print(this.getIntervalType(interval));
			
			Node event = events[interval];
			System.out.print("[" + event.getNr()+" " + event.getID() +"] "+Math.round(event.getDate()*100)/100.0);
			
			List<Node> outgoingLines = event.getChildren();
			if (outgoingLines != null) {
				System.out.print(" removed: ");
				for(Node node: outgoingLines){
					System.out.print(node.getNr()+" ");
				}
			}
			System.out.println(" ");
		}
    	System.out.println("--- end intervals--");
    	
    }
    
    public void checkIntervals() {   	 	
    	Node[] nodes = treeInput.get().getNodesAsArray();
    	for(int interval=0; interval < this.getIntervalCount(); interval++) {
    		IntervalType type = this.getIntervalType(interval);
    		Node event = nodes[indices[interval]];
    		if (indices[interval]!=event.getNr())
    			System.out.println("What!!??");
    		int num_children = event.getChildCount();
    		// List<Node> outLineages = event.getChildren();
    		if (type==IntervalType.SAMPLE) {
    			if (num_children!=0) System.out.println("Wrong SAMPLE!");
    		} else if (type==IntervalType.COALESCENT) {
    			if (num_children!=2) System.out.println("Wrong COALESCENT!");
    		} else
    			System.out.println("Nothing!!!");
    		if (events[interval] != event) {
    			System.out.println("Event node and index node do not match");
    		}
		}   	
    }
    
    // Sorting
    // Heapsort copied from Heapsort class
    
    /**
     * Compares two nodes of a tree based on height (first) and level (root has heighest level)
     * Implements a strict (non-reflexive) partial order on tree nodes: equal-height nodes
     * are ordered based on level. This is important for the zero-branch case: we want children to
     * show up before their respective parents (and vice-versa).
     * Returns a negative number if n1 'less-than' n2, positive otherwise.
     * Assumption: n1 < n2 ifi level(n1) < level(n2)
     * compare(n1,n2) = (h(n1)==h(n2))?(n1-n2):(h(n1)<h(n2)?-1:1)
     *
     * @param array   an array of doubles
     * @param indices an array of node nr's
     * @param n1 node nr
     * @param n2 node nr
     */
    
    static int compare(double[] array, int[] indices, int n1, int n2) {
    	if (array[indices[n1]]<array[indices[n2]]) {
    		return -1;
    	}
    	else if (array[indices[n1]] > array[indices[n2]]) {
    		return 1;
    	}
    	else {
    		return (indices[n1]-indices[n2]);
    	}
    }
    
 
    
    /**
     * Heap sort implementation taken from BEAST's HeapSort class.
     * 
     * Sorts an array of indices into an array of doubles
     * into increasing order.
     *
     * @param array   an array of doubles
     * @param indices an array of indices to be sorted so that they describe an ascending order of values in array
     */
    public static void heapsort(double[] array, int[] indices) {

        int temp;
        int j, n = indices.length;

        // turn input array into a heap
        for (j = n / 2; j > 0; j--) {
            adjust(array, indices, j, n);
        }

        // remove largest elements and put them at the end
        // of the unsorted region until you are finished
        for (j = n - 1; j > 0; j--) {
            temp = indices[0];
            indices[0] = indices[j];
            indices[j] = temp;
            adjust(array, indices, 1, j);
        }
    }
  
    /**
     * helps sort an array of indices into an array of doubles.
     * Assumes that array[lower+1] through to array[upper] is
     * already in heap form and then puts array[lower] to
     * array[upper] in heap form.
     *
     * @param array   array of doubles
     * @param indices array of indices into double array to sort
     * @param lower   lower index of heapify
     * @param upper   upper index of heapify
     */
    private static void adjust(double[] array, int[] indices, int lower, int upper) {

        int j, k;
        int temp;

        j = lower;
        k = lower * 2;

        while (k <= upper) {
        	// if ((k < upper) && (array[indices[k - 1]] < array[indices[k]])) {
            if ((k < upper) && (compare(array,indices,k-1,k) <= 0) ) {
                k += 1;
            }
            // if (array[indices[j - 1]] < array[indices[k - 1]]) {
            if (compare(array,indices,j-1,k-1) <= 0) {
                temp = indices[j - 1];
                indices[j - 1] = indices[k - 1];
                indices[k - 1] = temp;
            }
            j = k;
            k *= 2;
        }
    }
    
    
    /**
     * Standard heap sort implementation.
     * 
     * @param array   an array of doubles
     * @param indices an array of indices to be sorted so that they describe an ascending order of values in array
     */
    public static void heapsort2(double[] array, int[] indices) {

        // ensures we are starting with valid indices
    	// place root of heap at zero
        for (int i = 0; i < indices.length; i++) {
            indices[i] = indices.length-i-1;
        }

        int temp;
        int j, n = indices.length;
        int p,c;
        
        //System.out.println("starting sort 2");

        // Build heap
        for(j = 1; j < n; j++) {  // heapify up
        	c = j;
        	p = (c-1)/2;
        	while ( p>=0 ) {
        		if (  compare(array,indices,p,c) <=0  ) {
        		//if (array[indices[c]] > array[indices[p]]) {  // swap indices
        			temp = indices[c]; indices[c] = indices[p]; indices[p] = temp;
        			c = p;
        			p = (c-1)/2;
        		} else break;
        	}       	
        }
               
        // remove largest elements and put them at the end
        int k;
        for (j = n - 1; j > 0; j--) {
            temp = indices[0];
            indices[0] = indices[j];
            indices[j] = temp;
            p = 0;
            k = 2*p + 1;
            // heapify down
            while(k < j) { 
            		if (((k+1)<j)&& (compare(array,indices,k, k+1) <= 0)) {
            			k++;
            		}
            		if (compare(array,indices,p,k) <=0 ) {
            			//System.out.println(" swap: "+indices[p]+" <--> "+indices[k]);
            			temp = indices[p]; indices[p] = indices[k]; indices[k] = temp;
            			p = k;
            			k = 2*p + 1;            		
            		} else break;
            }           
        }
    }
    
    
}